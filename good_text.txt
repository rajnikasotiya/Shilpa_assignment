import pandas as pd
import json
import re
from transformers import pipeline
from sentence_transformers import SentenceTransformer, util

# === Load CSV ===
df = pd.read_csv("results3.csv")
record_text = str(df.loc[3, "context"])  # Take 4th record (index 3)

# === Field Definitions ===
FIELD_DEFINITIONS = {
    "Visit Reason": "Main complaint or reason why the patient came to the hospital.",
    "History": "Past medical history, chronic conditions, or relevant background information.",
    "Diagnosis": "The doctor's assessment or suspected/confirmed disease.",
    "Clinical Details": "Signs, symptoms, and clinical observations noted during examination.",
    "Lab Results": "Blood tests or laboratory values with findings.",
    "Treatment Plan": "Medications, therapies, or planned interventions.",
    "Vital Signs": "Objective measurements such as blood pressure, pulse, temperature, SpO2.",
    "Exam Results": "Findings from physical examination.",
    "Imaging Test Results": "Findings from imaging such as X-ray, CT, MRI, etc.",
    "Hospital Course": "Description of what happened during hospitalization or ER stay.",
    "Discharge Plan": "Follow-up instructions, discharge medications, and next steps.",
    "Full HPI": "Narrative description of the patient's history of present illness.",
    "Full Assessment and Plan": "Complete summary of assessment and treatment plan."
}

NARRATIVE_FIELDS = {"Full HPI", "Hospital Course", "Full Assessment and Plan"}
FIELDS = list(FIELD_DEFINITIONS.keys())

# === Load Models ===
extractor = pipeline("text2text-generation", model="google/flan-t5-base")
embedder = SentenceTransformer("sentence-transformers/all-MiniLM-L6-v2")

# === Prompt ===
prompt = (
    "Extract the following fields from the medical record and return the result in strict JSON format. "
    "The input text may not explicitly contain the field names, but may contain relevant information. "
    "For fields marked as 'Narrative', return a complete sentence that clearly defines the field. "
    "For fields marked as 'Short', return only short phrases or keywords that strictly define the field. "
    "If no clear, defining information is found for a field, return an empty list for that field.\n\n"
    "Fields with definitions and expected style:\n"
)

for field, definition in FIELD_DEFINITIONS.items():
    style = "Narrative" if field in NARRATIVE_FIELDS else "Short"
    prompt += f"{field} ({style}): {definition}\n"

prompt += f"\nReturn output as JSON with each field as a key and a list of extracted values.\n\nMedical Record:\n{record_text}"

# === Run Model ===
response = extractor(prompt, max_length=1834, clean_up_tokenization_spaces=True)[0]["generated_text"]

# === Try Parsing JSON Output ===
try:
    structured_data = json.loads(response)
except:
    structured_data = {}

# === Prepare text for fallback ===
sentences = [s.strip() for s in re.split(r'(?<=[.!?])\s+', record_text) if s.strip()]
sentence_embeddings = embedder.encode(sentences, convert_to_tensor=True)

# === Fallback (Only if strongly relevant â‰¥0.6) ===
for field in FIELDS:
    value = structured_data.get(field, [])
    if not value or (isinstance(value, list) and len(value) == 0):
        if sentences:
            query_text = FIELD_DEFINITIONS[field]
            field_embedding = embedder.encode(query_text, convert_to_tensor=True)
            similarity_scores = util.cos_sim(field_embedding, sentence_embeddings)[0]
            best_idx = int(similarity_scores.argmax())
            best_score = float(similarity_scores[best_idx])

            if best_score >= 0.6:  # Strict threshold: only take strongly relevant sentences
                fallback_text = sentences[best_idx]
                if field not in NARRATIVE_FIELDS:
                    fallback_text = " ".join([w for w in fallback_text.split() if len(w) > 2][:6])
                structured_data[field] = [fallback_text.strip()]
            else:
                structured_data[field] = []  # No truly relevant info found
        else:
            structured_data[field] = []  # No sentences at all

# === Clean Output (remove tabs/newlines/extra spaces) ===
cleaned_data = {}
for field in FIELDS:
    values = structured_data.get(field, [])
    cleaned_values = []
    for v in values:
        v_clean = re.sub(r'[\t\n\r]+', ' ', str(v)).strip()
        v_clean = re.sub(r'\s+', ' ', v_clean)
        if v_clean:
            cleaned_values.append(v_clean)
    cleaned_data[field] = cleaned_values

# === Final Strict Output ===
print(json.dumps(cleaned_data, indent=2, ensure_ascii=False))
